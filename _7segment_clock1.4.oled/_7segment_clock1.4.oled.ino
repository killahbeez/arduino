
#include <util/atomic.h>
#include <Wire.h>
#include <DS3231.h>

DS3231 clock;
RTCDateTime dt;


uint32_t ircomm = 0;
uint32_t last_ircomm = 0;

uint16_t shiftReg16[] = {0, 0, 0, 0, 0, 0, 0}; //7 digits display
uint16_t snapshot_shiftReg16[] = {0, 0, 0, 0, 0, 0, 0}; //7 digits display
int8_t crtDigit = 0;
uint8_t speed_scroll_set = 200;
uint32_t set_clock_number = 0;

#define countDigits sizeof(shiftReg16)/sizeof(shiftReg16[0])
#define countArr(number) sizeof(number)/sizeof(number[0])
#define diffMillis (millis() - last_millis)
#define DS PC0
#define SHCP PC1
#define STCP PC2

volatile boolean digits_refresh = 0;
volatile uint8_t tens_seconds = 0;
volatile boolean toggle_leds_second = 0;


uint8_t segm7_digits[10] = {
  0b11111100, //0
  0b01100000, //1
  0b11011010, //2
  0b11110010, //3
  0b01100110, //4
  0b10110110, //5
  0b10111110, //6
  0b11100000, //7
  0b11111110, //8
  0b11110110  //9
};

uint8_t adi[3] = {
  0b11101110, //A
  0b01111010, //d
  0b01100000 //I
};
volatile boolean scroll_text = 0;
volatile uint8_t scroll_cnt = 0;
uint8_t pos_logo = 0;

uint8_t pressed[] = {0, 0, 0};
uint8_t released[] = {1, 1, 1};

uint32_t millis_pressed[] = {0, 0, 0};
uint32_t millis_released[] = {0, 0, 0};

uint8_t snapshot_stage = 0;
uint8_t button_0_cycle = 0;
int32_t freeze_number = 0;
int32_t freeze_hour = 0;
int32_t freeze_minute = 0;
int32_t freeze_second = 0;
uint32_t last_millis = 0;
uint32_t first_press_millis = 0;
int8_t number_digits = 0;
boolean first_press = 1;
boolean show_temperature = 0;
boolean show_date = 0;
int8_t display_mode = 0;

char temperature[3];

volatile uint32_t cnt1 = 0;
boolean isOn = 1;
boolean loop_data = 0;
uint8_t loop_data_cnt = 0;
uint8_t loop_data_show = 3;
volatile boolean one_second = false;
uint16_t freq_multiplex;

char* timp;
char* data;
char bufferTemp[6];

boolean ResetVarsOFF = 0;

#include "U8glib.h"
U8GLIB_SSD1306_128X64 u8g(U8G_I2C_OPT_DEV_0 | U8G_I2C_OPT_NO_ACK | U8G_I2C_OPT_FAST);


boolean show_degree = 1;
int8_t last_temperature;
int8_t current_temperature;

uint32_t oled_millis = 0;
uint16_t stop_oled[] = {5000, 5000, 3000, 1000};

const uint8_t fist[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xd6, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0c, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x50, 0x0b, 0x00, 0x50, 0x15, 0x00, 0x00, 0x00, 0x00,
  0x04, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00,
  0x00, 0x40, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00,
  0x00, 0xc0, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x06, 0x00,
  0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x08, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x08, 0x00, 0x10, 0x80, 0x00,
  0x80, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00,
  0x00, 0x04, 0x00, 0x08, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x04, 0x00,
  0x04, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x80, 0x00,
  0x10, 0x00, 0x20, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x02, 0x80, 0x00, 0x08, 0x00, 0x20, 0x00, 0x02, 0x00,
  0x00, 0x40, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x40, 0x00,
  0x80, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x80, 0x00, 0x10, 0x00, 0x10,
  0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x01, 0x40, 0x00, 0x80, 0x00, 0x10, 0x00, 0x02, 0x00, 0x01, 0x40, 0x00,
  0x20, 0x00, 0x08, 0x00, 0x01, 0x00, 0x00, 0x80, 0x00, 0xa0, 0x00, 0x08,
  0x00, 0x02, 0x00, 0x01, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x02, 0x00,
  0x00, 0x40, 0x00, 0xc0, 0x00, 0x08, 0x00, 0x02, 0x00, 0x01, 0x20, 0x00,
  0x80, 0x00, 0x08, 0x00, 0x02, 0x00, 0x01, 0x20, 0x00, 0x80, 0x00, 0x08,
  0x00, 0x06, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x08, 0x00, 0x04, 0x00,
  0xa1, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x4c, 0x02, 0x01, 0x0c, 0x00,
  0x00, 0x01, 0x08, 0x00, 0x08, 0x00, 0x05, 0x03, 0x00, 0x00, 0x02, 0x08,
  0x00, 0x14, 0x80, 0xf4, 0x00, 0x00, 0x00, 0x22, 0x88, 0x00, 0x62, 0x70,
  0x00, 0x04, 0x00, 0x00, 0x0c, 0x18, 0x02, 0xe2, 0x17, 0x00, 0x00, 0x00,
  0x00, 0x70, 0x33, 0x80, 0x19, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xc0,
  0x50, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x02, 0x00,
  0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x01, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x04, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xae, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
  0x00, 0xa8, 0x17, 0x80, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68,
  0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00
};

const uint8_t pinup[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf4,
  0x0b, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xc0, 0x37, 0x74, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xd0, 0xa0, 0xa7, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x10,
  0xaf, 0x98, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x0e, 0x10, 0x00, 0x9f, 0x01, 0x0c, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x10, 0x00, 0xac, 0x0f, 0x0f,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x20,
  0x00, 0x5c, 0xff, 0xc9, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0xe0, 0x00, 0xe0, 0x12, 0x68, 0x77, 0x3c, 0x06, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0xc1, 0x6f, 0x00, 0xf4, 0x0f,
  0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x77,
  0x9d, 0x10, 0x00, 0x39, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x18, 0x00, 0xeb, 0x39, 0x00, 0x80, 0xc0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x62, 0x61, 0x00, 0x04, 0x01,
  0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0xe6,
  0x01, 0x85, 0x1f, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x06, 0x00, 0xb2, 0x01, 0x84, 0x1f, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x7f, 0x83, 0x00, 0x3e, 0x80,
  0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xab,
  0xc0, 0x05, 0x7e, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x01, 0x00, 0x5b, 0x00, 0x18, 0xff, 0xc0, 0x07, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x1f, 0x80, 0x00, 0xc0, 0x6a, 0x18, 0x60, 0xf9, 0xc8,
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x80, 0x00, 0xc0, 0x2d,
  0x08, 0x80, 0xf7, 0x61, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x20,
  0x70, 0x00, 0x40, 0x35, 0x04, 0x80, 0xe3, 0xfe, 0x05, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x60, 0x40, 0x6e, 0x30, 0xe0, 0x17, 0x04, 0x1c, 0x1f, 0x0a,
  0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0xc0, 0x01, 0x0c, 0x3c, 0x1b,
  0x02, 0x38, 0x8c, 0x50, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x43,
  0x20, 0x04, 0x0c, 0x0b, 0x00, 0x70, 0x00, 0xfe, 0x6f, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x23, 0x00, 0x02, 0x38, 0x0f, 0x00, 0xd0, 0x00, 0xff,
  0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0xb0, 0x2b,
  0x00, 0x98, 0x01, 0xf7, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
  0x00, 0x03, 0xf0, 0x06, 0x00, 0xb8, 0x80, 0xff, 0x4f, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x06, 0x00, 0x07, 0xd0, 0x26, 0x00, 0xbc, 0x02, 0xf3,
  0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x82, 0x00, 0xb0, 0x16,
  0x00, 0x7c, 0x02, 0xe0, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0xc2, 0x00, 0x50, 0x15, 0x00, 0xfc, 0x06, 0xe0, 0x41, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xc0, 0x80, 0x23, 0x00, 0xb0, 0x0f, 0x00, 0xfe, 0x0f, 0x40,
  0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x33, 0x00, 0x70, 0x09,
  0x00, 0x1e, 0x1f, 0x40, 0xea, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00,
  0x0e, 0x00, 0x90, 0x06, 0x00, 0x3e, 0x7a, 0x71, 0x1d, 0x03, 0x00, 0x00,
  0x00, 0x00, 0x10, 0x00, 0x0e, 0x00, 0xf0, 0x06, 0x00, 0x4e, 0x30, 0x6f,
  0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x06, 0x00, 0xe0, 0x07,
  0x00, 0x8e, 0x20, 0x42, 0x1a, 0x04, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
  0x02, 0x00, 0x20, 0x07, 0x00, 0x86, 0x20, 0xdb, 0x11, 0x02, 0x00, 0x00,
  0x00, 0x00, 0x08, 0x00, 0x02, 0x00, 0x10, 0x07, 0x00, 0x16, 0x71, 0xab,
  0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x38, 0x06,
  0x00, 0x16, 0xee, 0x66, 0x30, 0x02, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
  0x01, 0x00, 0xec, 0x0f, 0x00, 0x16, 0x72, 0x24, 0x10, 0x02, 0x00, 0x00,
  0x00, 0x80, 0x08, 0x00, 0x01, 0x00, 0xc0, 0x0d, 0x00, 0x36, 0xf1, 0x67,
  0x10, 0x04, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x01, 0x00, 0x40, 0x1d,
  0x00, 0x6e, 0x10, 0x60, 0x10, 0x04, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
  0x03, 0x00, 0xa0, 0x35, 0x00, 0xa2, 0x00, 0x60, 0x08, 0x04, 0x00, 0x00,
  0x00, 0x40, 0x00, 0x00, 0x03, 0x00, 0x1c, 0x3b, 0x00, 0xaa, 0xe8, 0x1e,
  0x0c, 0x06, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x80, 0x07, 0xa8, 0x05, 0x6b,
  0x00, 0x92, 0x5d, 0x50, 0x04, 0x0c, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80,
  0x02, 0xd0, 0x17, 0x7e, 0x01, 0x32, 0x87, 0x37, 0x02, 0x0c, 0x00, 0x00,
  0x00, 0x60, 0x58, 0x60, 0x02, 0x80, 0x05, 0x6c, 0x01, 0xe6, 0xf4, 0x60,
  0x02, 0x18, 0x00, 0x00, 0x00, 0x20, 0xf8, 0x3a, 0x02, 0xc0, 0x01, 0xe8,
  0x01, 0x04, 0x07, 0x20, 0x01, 0x18, 0x00, 0x00, 0x00, 0x30, 0xc0, 0x0b,
  0x02, 0x40, 0x02, 0x88, 0x03, 0x0c, 0x00, 0xb0, 0x00, 0x10, 0x00, 0x00,
  0x00, 0x10, 0xd0, 0x1e, 0x03, 0xc0, 0x07, 0xa4, 0x07, 0x08, 0x00, 0x4c,
  0x00, 0x30, 0x00, 0x00, 0x00, 0x18, 0x00, 0x30, 0x02, 0xc0, 0x1c, 0xf4,
  0x1e, 0xbc, 0x00, 0x7e, 0x00, 0x20, 0x00, 0x00, 0x00, 0x08, 0x00, 0x40,
  0x03, 0x80, 0x1c, 0x8e, 0xff, 0xff, 0xc1, 0xa1, 0x02, 0x00, 0x00, 0x00,
  0x00, 0x08, 0x00, 0x48, 0x02, 0x80, 0x60, 0x00, 0x78, 0xed, 0x7f, 0xf0,
  0x0a, 0x20, 0x00, 0x00, 0x00, 0x08, 0x00, 0x40, 0x02, 0x80, 0xc0, 0x01,
  0x74, 0xdc, 0x6f, 0x2f, 0x00, 0x10, 0x00, 0x00, 0x00, 0x18, 0x40, 0x50,
  0x06, 0x00, 0x5a, 0x0f, 0xc0, 0xfc, 0xd0, 0x0c, 0x08, 0x30, 0x00, 0x00,
  0x00, 0x30, 0x40, 0x58, 0x06, 0x00, 0xa0, 0xf8, 0xbf, 0x1e, 0x70, 0x00,
  0x02, 0x17, 0x00, 0x00, 0x00, 0xe0, 0x80, 0x70, 0x1c, 0x00, 0xc0, 0x84,
  0xd0, 0x02, 0x20, 0x04, 0x06, 0x0c, 0x00, 0x00, 0x00, 0xc0, 0x82, 0x18,
  0x2c, 0x00, 0xc0, 0xee, 0x80, 0x01, 0x20, 0x04, 0x02, 0x08, 0x00, 0x00,
  0x00, 0x00, 0x83, 0x18, 0x28, 0x00, 0xc0, 0x0d, 0x80, 0x01, 0x20, 0x04,
  0x02, 0x08, 0x00, 0x00, 0x00, 0x00, 0xac, 0x07, 0x10, 0x00, 0x40, 0x00,
  0x00, 0x00, 0x30, 0x04, 0x02, 0x08, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00,
  0xe0, 0x03, 0x40, 0x00, 0x00, 0x00, 0x20, 0x04, 0x02, 0x08, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x60, 0x00, 0x00, 0x00, 0x60, 0x04,
  0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x2d, 0x00,
  0x00, 0x00, 0xc0, 0x0c, 0x06, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0xbb, 0x03, 0x07, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
  0xbc, 0x01, 0x00, 0x00
};

void draw(void) {
  static uint32_t current_millis = 0;
  static uint32_t stop_millis = 0;
  static int16_t pixel = 128;
  static boolean stop_anim = 0;
  static uint8_t calup = 0;

  current_millis = millis();
  if (!stop_anim) {

    // graphic commands to redraw the complete screen should be placed here
    if (current_millis - oled_millis > 5) {
      sprintf(temperature, "%02d", (int8_t) clock.readTemperature());
      sprintf(bufferTemp, "%2s", temperature);

      if (pixel > -128) {
        pixel--;
      }
      else {
        pixel = 128;
        calup = ++calup % 3;
      }

      oled_millis = current_millis;
    }
  }


  switch (calup) {
    case 0:
      u8g.setFont(u8g_font_fub49n);
      u8g.drawStr( pixel + 25, 60, bufferTemp);
      u8g.drawDisc( pixel + 115, 15, 7);
      break;
    case 1:
      u8g.setFont(u8g_font_fub20r);
      u8g.drawStr( pixel, 34, clock.dateFormat("l", dt));
      u8g.drawStr( pixel + 30, 64, clock.dateFormat("d/m", dt));
      break;
    case 2:
      pixel = 0;
      u8g.drawXBMP( pixel + 25, 0, 68, 52, fist);
      u8g.setFont(u8g_font_helvR08r);
      u8g.drawStr( pixel + 70, 63, "Made by Adi");
      break;
    case 3:
      u8g.drawXBMP( pixel, 0, 128, 64, pinup);
      break;
  }


  if (pixel == 0) {
    if (!stop_anim) {
      stop_millis = current_millis;
    }
    stop_anim = 1;
    if (current_millis - stop_millis > stop_oled[calup]) {
      stop_anim = 0;

      if (calup == 2) {
        pixel = -128;
      }
    }
  }

}


void setup() {
  Serial.begin(9600);

  freq_multiplex = 1000;

  TCCR1A |= (1 << WGM10) | (1 << WGM11);
  TCCR1B = (1 << CS11) | (1 << CS10) | (1 << WGM12) | (1 << WGM13); // Normal port operation, 64 prescaller, Fast PWM OCRA
  OCR1A = 16000000 / 64 / freq_multiplex;
  TIMSK1 = (1 << TOIE1);

  DDRC |= (1 << DS) | (1 << SHCP) | (1 << STCP);
  DDRB |= (1 << PB3); // led toggle seconds OUTPUT

  DDRB &= ~(1 << PB0); // PB0 INPUT button 1
  PORTB |= (1 << PB0); //PB0 INPUT_PULLUP

  DDRD &= ~(1 << PD7); //PD7 INPUT button 2
  PORTD |= (1 << PD7); //PD7 INPUT_PULLUP

  DDRD &= ~(1 << PD6); //PD7 INPUT button 3
  PORTD |= (1 << PD6); //PD7 INPUT_PULLUP

  clock.begin();
  //clock.setDateTime(__DATE__, __TIME__);
  dt = clock.getDateTime();

  // assign default color value
  if ( u8g.getMode() == U8G_MODE_R3G3B2 ) {
    u8g.setColorIndex(255);     // white
  }
  else if ( u8g.getMode() == U8G_MODE_GRAY2BIT ) {
    u8g.setColorIndex(3);         // max intensity
  }
  else if ( u8g.getMode() == U8G_MODE_BW ) {
    u8g.setColorIndex(1);         // pixel on
  }
  else if ( u8g.getMode() == U8G_MODE_HICOLOR ) {
    u8g.setHiColorByRGB(255, 255, 255);
  }

}



void loop() {

  checkSwitchOnOff();
  if (isOn) {
    if (!button_0_cycle) {
      u8g.firstPage();
      do {
        draw();
      } while ( u8g.nextPage() );
    }

    ResetVarsOFF = 1;
    dt = clock.getDateTime();

    //press DATE button for more than 2 sec to switch off
    if (!buttonReleased(2) && (millis() - millis_pressed[2]) > 2000 && display_mode == 3) {
      isOn = 0;
      Serial.println("OFF");
      released[2] = 1;
      u8g.sleepOn();
    }

    //SETTING CLOCK
    //if the button 1 is pressed enter the setting stage
    //cycle throw setting pairs SS MM HH
    //on the fourth press release the setting stage
    if (buttonPressed(0) && display_mode == 1) {
      if (button_0_cycle == 3) {
        clock.setDateTime(dt.year, dt.month, dt.day, constrain(freeze_hour, 0, 59), constrain(freeze_minute, 0, 59), constrain(freeze_second, 0, 59)); //set CLOCK
      }
      button_0_cycle = ++button_0_cycle % 4;
      snapshot_stage = button_0_cycle;
      pressed[0] = 0;
    }

    if (button_0_cycle) {
      settingClock();
    }
    //END SETTING CLOCK

    //SHOW Clock
    if (!button_0_cycle && display_mode != 1 && (buttonPressed(0) || ircomm == 0xFD40BF || loop_data_show == 0)) {
      display_mode = 1;
      pressed[0] = 0;
      show_date = 0;
      show_temperature = 0;
      loop_data_show = 3;
    }
    //END SHOW Clock

    //SHOW Temperature
    if (!button_0_cycle && (buttonPressed(1) || ircomm == 0xFD609F || loop_data_show == 1) ) {
      show_temperature = !show_temperature;
      display_mode = (show_temperature) ? 2 : 1;
      pressed[1] = 0;
      show_date = 0;
      loop_data_show = 3;
    }
    //END SHOW Temperature

    //SHOW Date
    if (!button_0_cycle && (buttonPressed(2) || ircomm == 0xFD50AF || loop_data_show == 2) ) {
      show_date = !show_date;
      display_mode = (show_date) ? 3 : 1;
      pressed[2] = 0;
      show_temperature = 0;
      loop_data_show = 3;
    }
    //END SHOW Date

    //1/2 second ON 1/2 second off
    if (toggle_leds_second && !button_0_cycle && display_mode == 1) {
      PORTB ^= (1 << PB3);
      toggle_leds_second = 0;
    }

    if (digits_refresh && display_mode == 2) {
      sprintf(temperature, "%02d", (int8_t) clock.readTemperature());
    }

    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
      if (digits_refresh) {
        if (display_mode == 1) {
          timp = clock.dateFormat("Gis", dt);
        }
        if (display_mode == 3) {
          data = clock.dateFormat("dmy", dt);
        }
      }

      digits_refresh = 0;
    }

  }

  if (!isOn) {
    if (ResetVarsOFF) {
      PORTB &= ~(1 << PB3); //turnOff seconds leds
      button_0_cycle = 0;
      pos_logo = 0;
      scroll_text = 0;
      scroll_cnt = 0;
      display_mode = 0;
      resetClock();
      resetNumbers();

      //lcd.clear();
      //lcd.setBacklight(LOW);
      ResetVarsOFF = 0;
    }

    //press DATE button for more than 2 sec to switch on
    if (!buttonReleased(2) && (millis() - millis_pressed[2]) > 2000) {
      pressed[2] = 0;
      released[2] = 0;
      //lcd.setBacklight(HIGH);
      Serial.println("ON");
      last_temperature = 0;
      show_degree = 1;

      pos_logo = 0;
      scroll_text = 0;
      scroll_cnt = 0;

      u8g.sleepOff();

      isOn = 1;
    }
  }

  //every 1 sec
  if (one_second) {
    one_second = false;

    if (loop_data && display_mode != 0) {

      if (loop_data_cnt == 30) {
        loop_data_show = 1;
      }
      if (loop_data_cnt == 31) {
        loop_data_show = 2;
      }
      if (loop_data_cnt == 32) {
        loop_data_show = 0;
        loop_data_cnt = 0;
      }

      loop_data_cnt++;
    }

  }

}

void checkSwitchOnOff() {
  if (ircomm == 0xFD708F) {
    isOn = !isOn;

    pos_logo = 0;
    scroll_text = 0;
    scroll_cnt = 0;
  }
}

void getSnapshot() {
  for (int i = 0; i < countArr(shiftReg16); i++) {
    snapshot_shiftReg16[i] = shiftReg16[i];
  }
}

void setToSnapshot() {
  for (int i = 0; i < countArr(snapshot_shiftReg16); i++) {
    shiftReg16[i] = snapshot_shiftReg16[i];
  }
}

void settingClock() {
  if (buttonPressed(1)) { // if UP button is pressed
    if (first_press) {
      speed_scroll_set = 200;
    }
    if (button_0_cycle == 1 && diffMillis > speed_scroll_set) { // if UP on HH
      freeze_hour = ++freeze_hour % 24;
      snapshot_shiftReg16[5] = segm7_digits[freeze_hour % 10];
      if (freeze_hour > 9) {
        snapshot_shiftReg16[6] = segm7_digits[freeze_hour / 10];
      }
      else {
        snapshot_shiftReg16[6] = 0;
      }
      last_millis = millis();

      if (first_press) {
        first_press_millis = millis();
        first_press = false;
      }

      if ( (millis() - first_press_millis) > 1000) {
        speed_scroll_set = 70;
      }
    }
    if (button_0_cycle == 2 && diffMillis > speed_scroll_set) { // if UP on MM
      freeze_minute = ++freeze_minute % 60;
      snapshot_shiftReg16[3] = segm7_digits[freeze_minute % 10];
      snapshot_shiftReg16[4] = segm7_digits[freeze_minute / 10];
      last_millis = millis();
      if (first_press) {
        first_press_millis = millis();
        first_press = false;
      }

      if ( (millis() - first_press_millis) > 1000) {
        speed_scroll_set = 70;
      }
    }
    if (button_0_cycle == 3 && diffMillis > speed_scroll_set) { // if UP on SS
      freeze_second = ++freeze_second % 60;
      snapshot_shiftReg16[1] = segm7_digits[freeze_second % 10];
      snapshot_shiftReg16[2] = segm7_digits[freeze_second / 10];
      last_millis = millis();
      if (first_press) {
        first_press_millis = millis();
        first_press = false;
      }

      if ( (millis() - first_press_millis) > 1000) {
        speed_scroll_set = 70;
      }
    }
    //pressed[1] = 0;
  }

  if (buttonPressed(2)) { // if DOWN button is pressed
    if (first_press) {
      speed_scroll_set = 200;
    }
    if (button_0_cycle == 1 && diffMillis > speed_scroll_set) { // if DOWN on HH
      freeze_hour = --freeze_hour;
      if (freeze_hour < 0) {
        freeze_hour = 23;
      }
      snapshot_shiftReg16[5] = segm7_digits[freeze_hour % 10];
      if (freeze_hour > 9) {
        snapshot_shiftReg16[6] = segm7_digits[freeze_hour / 10];
      }
      else {
        snapshot_shiftReg16[6] = 0;
      }
      last_millis = millis();
      if (first_press) {
        first_press_millis = millis();
        first_press = false;
      }

      if ( (millis() - first_press_millis) > 1000) {
        speed_scroll_set = 70;
      }
    }
    if (button_0_cycle == 2 && diffMillis > speed_scroll_set) { // if DOWN on MM
      freeze_minute = --freeze_minute;
      if (freeze_minute < 0) {
        freeze_minute = 59;
      }
      snapshot_shiftReg16[3] = segm7_digits[freeze_minute % 10];
      snapshot_shiftReg16[4] = segm7_digits[freeze_minute / 10];
      last_millis = millis();
      if (first_press) {
        first_press_millis = millis();
        first_press = false;
      }

      if ( (millis() - first_press_millis) > 1000) {
        speed_scroll_set = 70;
      }
    }
    if (button_0_cycle == 3 && diffMillis > speed_scroll_set) { // if DOWN on SS
      freeze_second = --freeze_second;
      if (freeze_second < 0) {
        freeze_second = 59;
      }

      snapshot_shiftReg16[1] = segm7_digits[freeze_second % 10];
      snapshot_shiftReg16[2] = segm7_digits[freeze_second / 10];
      last_millis = millis();
      if (first_press) {
        first_press_millis = millis();
        first_press = false;
      }

      if ( (millis() - first_press_millis) > 1000) { //speed up after 1 sec
        speed_scroll_set = 70;
      }
    }
    //pressed[2] = 0;


  }

}

void setBinaryDigits(char number[], uint8_t cnt_array) {
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    uint8_t cnt = 0;
    resetNumbers();
    for (int8_t i = cnt_array - 1; i >= 0; i--) {
      shiftReg16[cnt] = segm7_digits[number[i] - 48];
      cnt++;
    }
  }
}

void setTemperatureDigits(char number[]) {
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    resetNumbers();
    shiftReg16[1] = 0b10011100;
    shiftReg16[2] = 0b11000110;
    shiftReg16[3] = segm7_digits[number[1] - 48];
    if (number[0] - 48 != 0) {
      shiftReg16[4] = segm7_digits[number[0] - 48];
    }
  }
}

void setDateDigits(char number[]) {
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    uint8_t cnt = 1;
    resetNumbers();
    for (int8_t i = 5; i >= 0; i--) {
      shiftReg16[cnt] = segm7_digits[number[i] - 48];
      cnt++;
    }
  }
}

void setAdiLogo(uint8_t pos) {
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    resetNumbers();
    shiftReg16[pos] = adi[0];
    shiftReg16[pos - 1] = adi[1];
    shiftReg16[pos - 2] = adi[2];
  }
}

void writeDigits(uint8_t digit, uint8_t pos) {
  uint8_t crt_bit = 0;
  static uint16_t num_display;

  num_display = digit << 8 | 128 >> pos;
  PORTC &= ~(1 << STCP);

  for (uint8_t i = 0; i < 16; i++) {
    PORTC &= ~(1 << SHCP);
    crt_bit = (num_display >> i) & 1;

    if (crt_bit == 1) {
      PORTC |= (1 << DS);
    }
    else {
      PORTC &= ~(1 << DS);
    }

    PORTC |= (1 << SHCP);
  }
  PORTC |= (1 << STCP);

}

void resetClock() {
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    PORTC &= ~(1 << STCP);

    for (uint8_t i = 0; i < 16; i++) {
      PORTC &= ~(1 << SHCP);
      PORTC &= ~(1 << DS);
      PORTC |= (1 << SHCP);
    }

    PORTC |= (1 << STCP);
  }

}

void resetNumbers() { //reset all digits to NULL (0)
  for (uint8_t i = 0; i < countDigits; i++) {
    shiftReg16[i] = 0;
  }
}



ISR(TIMER1_OVF_vect) {

  digits_refresh = 1;

  static uint32_t cnt = 0;

  // 1/10 seconds
  if (cnt % (freq_multiplex / 10) == 0) {
    tens_seconds = ++tens_seconds % 10;
    //scroll text every 200ms
    //if (tens_seconds % 2 == 0)  {
    if (display_mode == 0) {
      scroll_text = 1;
      if (scroll_cnt <= 12) {
        scroll_cnt++;
      }
    }
    //}
    cnt = 0;
  }
  cnt++;

  //every 1/2 of second
  if (cnt1 % (freq_multiplex / 2) == 0) {
    toggle_leds_second = 1;
  }

  //every 1 sec
  if (cnt1 % freq_multiplex == 0) {
    cnt1 = 0;
    one_second = true;
  }

  cnt1++;

  //check debounce every 5ms
  if ((cnt1 % (int)(0.005 / (1.0 / (float)freq_multiplex))) == 0) {
    debouncePress();
  }

  if (isOn) {
    digitsRefresh();
  }
}

void digitsRefresh() {
  resetClock();
  if (display_mode == 0) {
    if (scroll_cnt <= 12) {
      last_millis = 0;
      if (scroll_text == 1) {
        scroll_text = 0;
        pos_logo++;
      }
      if (pos_logo >= 9) {
        pos_logo = 1;
      }
    }
    else {
      if (last_millis == 0) {
        last_millis = millis();
      }
      if (diffMillis > 2000) { //after 2 seconds go the clock display
        scroll_cnt = 0;
        display_mode = 1;
      }
    }

    setAdiLogo(pos_logo);
    if (pos_logo - crtDigit >= 0) {
      writeDigits(shiftReg16[pos_logo - crtDigit], pos_logo - crtDigit);
    }

    crtDigit = (++crtDigit) % countArr(adi);
  }

  if (display_mode == 1) {
    char timp_plus_tenth[strlen(timp) + 2];

    sprintf(timp_plus_tenth, "%s%d", timp, tens_seconds);

    number_digits = strlen(timp_plus_tenth);
    setBinaryDigits(timp_plus_tenth, number_digits);

    ////////DISPLAY Setting clock
    if (button_0_cycle) { // HH
      if (snapshot_stage == 1) { //get a snapshot clock
        getSnapshot();
        set_clock_number = atol(timp_plus_tenth);
        freeze_hour = set_clock_number / 100000;
        freeze_minute = (set_clock_number % 100000) / 1000;
        freeze_second = (set_clock_number % 1000) / 10;
        PORTB &= ~(1 << PB3);
      }

      if (button_0_cycle == 1) {
        snapshot_shiftReg16[5] = snapshot_shiftReg16[5] | 1; // show setting state on DOT
      }
      if (button_0_cycle == 2) {
        snapshot_shiftReg16[5] &= ~(1 << 0); //reset the old dot
        snapshot_shiftReg16[3] = snapshot_shiftReg16[3] | 1; // show setting state on DOT
      }
      if (button_0_cycle == 3) {
        snapshot_shiftReg16[3] &= ~(1 << 0); //reset the old dot
        snapshot_shiftReg16[1] = snapshot_shiftReg16[1] | 1; // show setting state on DOT
      }
      setToSnapshot();
      number_digits = (freeze_hour < 10) ? 6 : 7;
    }

    snapshot_stage = 0;
    //////END DISPLAY Setting clock


    writeDigits(shiftReg16[crtDigit], crtDigit);

    crtDigit = (++crtDigit) % number_digits;
  }

  if (display_mode == 2) {
    PORTB &= ~(1 << PB3);
    setTemperatureDigits(temperature);
    crtDigit++;
    if (crtDigit > 4) {
      crtDigit = 1;
    }
    writeDigits(shiftReg16[crtDigit], crtDigit);
  }

  if (display_mode == 3) {
    PORTB |= (1 << PB3);

    setDateDigits(data);
    crtDigit++;
    if (crtDigit > 6) {
      crtDigit = 1;
    }
    writeDigits(shiftReg16[crtDigit], crtDigit);
  }
}

void debouncePress() {

  volatile static uint8_t pins[] = {PB0, PD7, PD6};
  volatile uint8_t pinb_arr[] = {PINB, PIND, PIND};
  volatile static uint8_t isPushed[] = {0, 0, 0};
  volatile static uint8_t lastState[] = {0, 0, 0};
  volatile static uint8_t count[] = {0, 0, 0};

  for (uint8_t i = 0; i < countArr(pins); i++) {

    isPushed[i] = ( ( pinb_arr[i] & (1 << pins[i]) ) == 0);

    //check if button was pressed
    if (isPushed[i] && !lastState[i]) { // if pressed
      count[i]++;
      // if button has not bounce for 4 checks, the button is debounce and considered pressed
      if (count[i] >= 4) {
        lastState[i] = isPushed[i];
        pressed[i] = 1;
        released[i] = 0;
        millis_pressed[i] = millis();
        count[i] = 0;
        first_press = true;
      }
    }
    else if (!isPushed[i] && lastState[i]) { //if released
      lastState[i] = isPushed[i];
      millis_released[i] = millis();
      pressed[i] = 0;
      released[i] = 1;
      count[i] = 0;
    }
    else if (!isPushed[i]) {
      count[i] = 0;
    }
  }

}

boolean buttonPressed(uint8_t pin) {
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    if (pressed[pin]) {
      return true;
    }

    return false;
  }
}

boolean buttonReleased(uint8_t pin) {
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    if (released[pin]) {
      return true;
    }

    return false;
  }
}

void delayNew(uint32_t tm) {
  uint32_t last_millis = millis();
  while ((millis() - last_millis) < tm) {}
}

